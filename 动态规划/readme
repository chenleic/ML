设计动态规划步骤：
1.刻画最优解的结构特征
2.递归定义最优解的值
3.计算最优解的值
4.利用计算出的信息构造一个最优解
1-3是该算法求解问题的基础。如要求解问题本身，需要执行第四步

使用动态规划方法求解应该具备两个要素:
1.最优子结构
	发掘最优子结构的通用模式：
	1).做出一个选择，例如选择钢条的第一个切割位置
	2).在其可能的第一步选择中，你假定已经知道哪种选择才是最优的
	3).确定这次选择会产生哪些子问题，以及如何更好的刻画子问题空间
	4).利用"剪切-黏贴"法证明。
     子问题无关。含义:同一个原问题的一个子问题的解不影响另一个子问题的解
2.子问题重叠 
子问题空间必须足够小，即问题的递归算法会反复的求解相同的子问题，而不是一直生成新的子问题

动态规划例子:
	钢条长度和价格分布，求截钢条的最佳方案.
	length:[1,2,3,4,5,  6, 7, 8, 9,10]
	price：[1,5,8,9,10,17,17,20,24,30]
	max:r(n) = max(p(i) + r(n-i))   1=<i =<n

自顶向下递归伪代码：
	CUT-ROD(p,n)
		if n==0 then
			return 0
		q = -无穷大
		for(int i=1; i<=n;i++) {
			q = max(q,p[i]+CUT-ROD(p,n-i));
		}
	return q

	上面的效率低，重复计算值。
	带备忘录的自顶向下法：
	CUT-ROD-MEM(p,n,mem)
		if mem[n] >= 0 then
			return mem[n];
		end
		if n == 0 then
			mem[0] = 0;
			return 0;
		end

		q = 负无穷大
		for(int i = 1; i<=n; i++) {
			q = max(q,p[i]+CUT-ROD-MEM(p,n-i));
		}
		mem[n] = q;
		return q


自底向上法：
		BOTTOM-TO-UP-CUT-ROD(p,n)
			int r[n+1] = {0};

			for j =1 to n then
				q = -1;
				for i = 1 to j then
					q = max(q, p[i] + r[j-i]);
				end
				r[j] = q
			end
		return r[n];